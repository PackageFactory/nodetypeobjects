<?php

declare(strict_types=1);

namespace PackageFactory\NodeTypeObjects\Factory;

use Neos\Utility\Unicode\Functions as UnicodeFunctions;
use PackageFactory\NodeTypeObjects\Domain\NodePropertySpecification;
use PackageFactory\NodeTypeObjects\Domain\NodeTypeObjectFile;
use PackageFactory\NodeTypeObjects\Domain\NodeTypeObjectSpecification;

class NodeTypeObjectFileFactory
{
    public function createNodeTypeObjectPhpCodeFromNode(
        NodeTypeObjectSpecification $specification,
    ): NodeTypeObjectFile {
        $propertyAccessors = '';
        $internalPropertyAccessors = '';
        foreach ($specification->properties as $property) {
            $propertyType = $property->propertyType;
            $propertyDefaultValue = $property->defaultValue;
            $propertyName = $property->propertyName;
            $propertyIsInternal = str_starts_with($property->propertyName, '_');
            if ($propertyIsInternal) {
                $methodName = 'getInternal' . UnicodeFunctions::ucfirst(substr($propertyName, 1));
            } else {
                $methodName = 'get' . UnicodeFunctions::ucfirst($propertyName);
            }

            $annotationType = null;
            $phpType = $propertyType;

            if (str_ends_with($propertyType, '[]')) {
                $annotationType = $propertyType;
                $phpType = 'array';
            } elseif (str_starts_with($propertyType, 'array<') && str_ends_with($propertyType, '>')) {
                $annotationType = substr($propertyType, 6, -1) . '[]';
                $phpType = 'array';
            } elseif ($propertyType  === 'boolean') {
                $phpType = 'bool';
            } elseif ($propertyType  === 'integer') {
                $phpType = 'int';
            } elseif ($propertyType  === 'DateTime') {
                $phpType = '\DateTime';
            }

            if (str_contains($phpType, '\\') && !str_starts_with($phpType, '\\')) {
                $phpType =  '\\' . $phpType;
            }
            if (is_string($annotationType) && str_contains($annotationType, '\\') && !str_starts_with($annotationType, '\\')) {
                $annotationType =  '\\' . $annotationType;
            }

            $returnType = ($propertyDefaultValue === null) ? '?' . $phpType : $phpType;

            $defaultReturn = match(true) {
                ($propertyType === 'DateTime' && is_string($propertyDefaultValue)) => 'new \DateTime(\'' . $propertyDefaultValue . '\')',
                default => var_export($propertyDefaultValue, true),
            };

            $typeCheck = match($phpType) {
                'null' => 'is_null($value)',
                'string' => 'is_string($value)',
                'int' => 'is_int($value)',
                'float' => 'is_float($value)',
                'bool' => 'is_bool($value)',
                'array' => 'is_array($value)',
                default => '$value instanceof ' . $phpType,
            };

            if ($annotationType) {
                $propertyAccessor = <<<EOL

                    /**
                     * @return ?$annotationType;
                     */
                    public function $methodName(): $returnType
                    {
                        \$value = \$this->node->getProperty('$propertyName');
                        if ($typeCheck) {
                            return \$value;
                        }
                        return $defaultReturn;
                    }

                EOL;
            } else {
                $propertyAccessor = <<<EOL

                    public function $methodName(): $returnType
                    {
                        \$value = \$this->node->getProperty('$propertyName');
                        if ($typeCheck) {
                            return \$value;
                        }
                        return $defaultReturn;
                    }

                EOL;
            }

            if ($propertyIsInternal) {
                $internalPropertyAccessors .= $propertyAccessor;
            } else {
                $propertyAccessors .= $propertyAccessor;
            }
        }

        $nodeTypeName = $specification->nodeTypeName;

        $classNameParts = explode('\\', $specification->className);
        $shortName = array_pop($classNameParts);
        $namespace = implode('\\', $classNameParts);

        $class = <<<EOL
        <?php

        declare(strict_types=1);

        namespace $namespace;

        use Neos\ContentRepository\Core\Projection\ContentGraph\Node;
        use Neos\Flow\Annotations as Flow;

        /**
         * AUTOGENERATED CODE ... DO NOT MODIFY !!!
         *
         * run `./ nodetypeobjects:build` to regenerate this
         */
        #[Flow\Proxy(false)]
        final readonly class $shortName
        {
            private function __construct(
                public Node \$node
            ) {
            }

            public static function fromNode(Node \$node): self
            {
                if (\$node->nodeTypeName->value !== "$nodeTypeName") {
                    throw new \Exception("unsupported nodetype " . \$node->nodeTypeName->value);
                }
                return new self(\$node);
            }

            // property accessors
            $propertyAccessors

            // internal property accessors
            $internalPropertyAccessors
        }

        EOL;

        return new NodeTypeObjectFile(
            $specification->fileNameWithPath,
            $class
        );
    }
}
