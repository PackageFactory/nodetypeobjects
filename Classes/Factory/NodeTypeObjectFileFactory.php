<?php

declare(strict_types=1);

namespace PackageFactory\NodeTypeObjects\Factory;

use Neos\Utility\Unicode\Functions as UnicodeFunctions;
use PackageFactory\NodeTypeObjects\Domain\NodeTypeObjectFile;
use PackageFactory\NodeTypeObjects\Domain\NodeTypeObjectSpecification;

class NodeTypeObjectFileFactory
{
    public function createNodeTypeObjectPhpCodeFromNode(
        NodeTypeObjectSpecification $specification,
    ): NodeTypeObjectFile {
        $propertyAccessors = '';
        foreach ($specification->properties as $property) {
            $propertyType = $property->propertyType;
            $propertyName = $property->propertyName;
            if (str_starts_with($property->propertyName, '_')) {
                $methodName = 'getInternal' . UnicodeFunctions::ucfirst(substr($propertyName, 1));
            } else {
                $methodName = 'get' . UnicodeFunctions::ucfirst($propertyName);
            }

            $annotationType = null;
            $phpType = $propertyType;

            if (str_ends_with($propertyType, '[]')) {
                $annotationType = $propertyType;
                $phpType = 'array';
            } elseif (str_starts_with($propertyType, 'array<') && str_ends_with($propertyType, '>')) {
                $annotationType = substr($propertyType, 6, -1) . '[]';
                $phpType = 'array';
            } elseif ($propertyType  === 'boolean') {
                $phpType = 'bool';
            } elseif ($propertyType  === 'integer') {
                $phpType = 'int';
            } elseif ($propertyType  === 'DateTime') {
                $phpType = '\DateTime';
            }

            if (str_contains($phpType, '\\') && !str_starts_with($phpType, '\\')) {
                $phpType =  '\\' . $phpType;
            }
            if (is_string($annotationType) && str_contains($annotationType, '\\') && !str_starts_with($annotationType, '\\')) {
                $annotationType =  '\\' . $annotationType;
            }

            if ($annotationType) {
                $propertyAccessors .= <<<EOL


                    /**
                     * @return ?$annotationType;
                     */
                    public function $methodName(): ?$phpType
                    {
                        return \$this->node->getProperty('$propertyName');
                    }
                EOL;
            } else {
                $propertyAccessors .= <<<EOL


                    public function $methodName(): ?$phpType
                    {
                        return \$this->node->getProperty('$propertyName');
                    }
                EOL;
            }
        }

        $nodeTypeName = $specification->nodeTypeName;

        $classNameParts = explode('\\', $specification->className);
        $shortName = array_pop($classNameParts);
        $namespace = implode('\\', $classNameParts);

        $class = <<<EOL
        <?php

        declare(strict_types=1);

        namespace $namespace;

        use Neos\ContentRepository\Domain\Model\NodeInterface;
        use Neos\Flow\Annotations as Flow;

        /**
         * AUTOGENERATED CODE ... DO NOT MODIFY !!!
         *
         * run `./ nodetypeobjects:build` to regenerate this
         */
        #[Flow\Proxy(false)]
        final readonly class $shortName
        {
            private function __construct(
                public NodeInterface \$node
            ) {
            }

            public static function fromNode(NodeInterface \$node): self
            {
                if (\$node->getNodeType()->getName() !== "$nodeTypeName") {
                    throw new \Exception("unsupported nodetype " . \$node->getNodeType()->getName());
                }
                return new self(\$node);
            }$propertyAccessors
        }

        EOL;

        return new NodeTypeObjectFile(
            $specification->fileNameWithPath,
            $class
        );
    }
}
